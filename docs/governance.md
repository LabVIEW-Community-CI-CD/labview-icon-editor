NI Open Source Initiative Bylaws
Table of Contents
Introduction
Roles and Responsibilities
NI Open Source Program Manager
Technical Steering Committee
Contribution Workflows
Standard Contribution Process
Experimental Branches for Large Features
Decision-Making Authority and Governance
CI/CD Integration and Release
Community Expectations and Code of Conduct
Conclusion and Encouragement
Introduction
Welcome to the NI Open Source Initiative Bylaws. This document serves as a transparent operational guide for how NI (National Instruments) open source projects are run. It is intended for both new contributors and Steering Committee members to understand how we collaborate, make decisions, and integrate contributions. The goal is to foster a collaborative, transparent, and sustainable environment where community contributions drive NI‚Äôs open source projects forward in harmony with NI‚Äôs product ecosystem. Many NI open source repositories (for example, the LabVIEW Icon Editor) directly influence official NI products. In fact, some NI products automatically pull code from these open source repos for their releases‚Äã
GITHUB.COM
. This means your contributions can become part of NI‚Äôs products, reaching a wide audience of users. These bylaws clarify how that process works ‚Äì from proposing changes, to getting them reviewed and merged, all the way to seeing them in production. We‚Äôve written this in a lightweight tone and structured format to make it easy to navigate and understand. Whether you‚Äôre a developer submitting a fix, or a Steering Committee member reviewing a major new feature, this guide will help us stay aligned. Below, we outline the roles involved, the contribution workflow, who has decision authority, how continuous integration (CI) ties in, and the expectations for everyone‚Äôs behavior. Let‚Äôs build great things together, with openness and respect! üöÄ
Roles and Responsibilities
Open collaboration works best when everyone understands the various roles and their responsibilities. NI‚Äôs open source projects are governed by a mix of NI employees and community members, each with clear duties. The two key roles in our governance model are the NI Open Source Program Manager and the Technical Steering Committee. We describe each below, along with how they interact. (In practice, there may be additional maintainers or contributors, but the following roles are central to decision-making and oversight.)
NI Open Source Program Manager
The NI Open Source Program Manager is an NI-appointed person responsible for the overall health and direction of the open source project. They act as the bridge between NI‚Äôs internal teams and the external community. Their responsibilities include:
Strategic Oversight: Ensuring that the project‚Äôs roadmap aligns with NI‚Äôs product and business goals. Major roadmap decisions or pivots are guided by the Program Manager on behalf of NI (a ‚ÄúBDFL‚Äù-style oversight), while day-to-day decisions are left to the community steering committee‚Äã
GITHUB.COM
. In other words, the Program Manager has veto or final say on big-picture decisions to keep the project in sync with NI‚Äôs needs, but generally trusts the community for routine choices.
Facilitating Contributions: Making sure that external contributions can be integrated smoothly. This means the Program Manager helps remove blockers (e.g. clarifying requirements, providing resources) and ensures processes like the Contributor License Agreement (CLA) are in place. For instance, they verify that all contributors sign NI‚Äôs CLA so that NI has the legal rights to use the contributions in products‚Äã
GITHUB.COM
.
Administrative Duties: Overseeing repository settings, CI/CD credentials, and other administrative aspects. They often trigger special workflows or events that require NI authorization. For example, enabling artifact distribution for an experimental branch requires a manual approval step by an NI admin‚Äã
GITHUB.COM
 ‚Äì the Program Manager (or another NI maintainer) would perform such an action. They are also responsible for final merge approvals of long-running branches once all criteria are met.
Steering Committee Support: The Program Manager typically chairs or coordinates the Steering Committee. They do not micromanage, but they‚Äôre present to offer guidance, answer questions about NI‚Äôs internal roadmap, and ensure the committee‚Äôs decisions are documented and followed. If needed, they mediate disagreements and make the tough calls that the committee can‚Äôt easily resolve.
Liaison to NI: As NI‚Äôs representative, they communicate the open source project‚Äôs status and needs to NI‚Äôs internal teams. This ensures NI‚Äôs product groups are aware of community-driven changes coming down the pipeline. It also means that contributors‚Äô work is acknowledged internally and considered in NI‚Äôs product release planning.
In summary, the NI Open Source Program Manager provides high-level direction, ensures legal/operational frameworks, and empowers the community to contribute effectively. They embody NI‚Äôs commitment to the project, keeping it on track and integrated with NI‚Äôs broader ecosystem.
Technical Steering Committee
Each NI open source project has a Technical Steering Committee (TSC), which is the driving force for day-to-day development and technical decision-making. The Steering Committee is composed of both NI engineers and select community contributors who have demonstrated expertise and commitment to the project‚Äã
GITHUB.COM
. This blend of NI and community membership reflects our collaborative governance model ‚Äì we work together to guide the project. Responsibilities of the Steering Committee include:
Issue Triage & Roadmapping: The committee regularly reviews issues and feature requests. They decide which features or bug fixes are ready for community contributions. When the committee agrees an issue is well-scoped and aligned with the project goals, they label it as ‚ÄúWorkflow: Open to contribution‚Äù‚Äã
GITHUB.COM
. This signals to everyone that the work can be picked up by outside contributors. They might also maintain a roadmap of features, balancing community interest with NI‚Äôs product timelines.
Assigning and Mentoring Contributors: Steering Committee members or maintainers will assign issues to contributors who volunteer (especially first-time contributors)‚Äã
GITHUB.COM
. If someone comments on an issue saying ‚ÄúI‚Äôd like to work on this,‚Äù a committee member will ensure they understand the scope and then assign it to them. Throughout the development process, committee members may provide guidance, answer questions, or point the contributor to relevant resources (design docs, examples, etc.).
Code Review and Quality Control: Perhaps the most important duty is reviewing pull requests (PRs) from contributors. The committee collectively reviews incoming PRs for code quality, correctness, tests, and adherence to guidelines. They provide constructive feedback and request changes if needed. The goal is to maintain the project‚Äôs quality bar while helping contributors improve their contributions.
Merging Contributions: Once a contribution has been reviewed and any feedback addressed, the Steering Committee has the authority to merge the pull request. At least one committee member (often more) will approve the PR, and after all required CI checks pass, a committee member will perform the merge‚Äã
GITHUB.COM
. The committee ensures that no code is merged until it meets our standards and passes automated tests. For routine features and fixes, the committee‚Äôs approval is sufficient to merge into the main development branch.
Releases and Integration: The committee coordinates with the Program Manager on preparing releases. For projects that feed into NI products, the committee verifies that merged changes are stable before those changes get pulled into an official product build. They might decide to hold off on merging something if it needs more bake time or conflicts with an upcoming release freeze. In essence, they act as the guardians of the codebase.
Community Engagement: Steering Committee members are also community leaders. They initiate or participate in discussions on GitHub (issues/discussions) or on communication channels like Discord. They listen to community feedback and represent the community‚Äôs perspective in internal NI conversations. In many cases, they are long-term contributors who deeply understand the project, so they help onboard new contributors and foster an inclusive environment.
Steering Committee membership is typically by invitation or nomination, based on a contributor‚Äôs proven contributions and alignment with project values. Members are expected to act in the best interest of the project and community. The committee may periodically rotate or expand to incorporate new active contributors. All their work, from labeling issues to reviewing code, is done in the open for transparency. By having a diverse Steering Committee, NI ensures that project direction is a collaborative effort between NI and the community, rather than a top-down mandate. (Note: In many cases, Steering Committee members are also the repository maintainers with direct write access. We use the term ‚ÄúSteering Committee‚Äù to emphasize their governance role. Maintainers not on the formal committee may still help with reviews and minor decisions, but major decisions and approvals come through the committee.)
Contribution Workflows
We welcome contributions from anyone ‚Äì whether it‚Äôs a bug fix, a new feature, better documentation, or testing and feedback. This section describes how you can contribute to an NI open source project, and what to expect at each step. Following this workflow helps ensure that your work is aligned with project needs and that it can be smoothly merged and released. We have a standard contribution process for typical changes, and an experimental feature process for larger, long-running efforts. Both are designed to be transparent and contributor-friendly. Before you begin, please familiarize yourself with the repository‚Äôs README.md (for an overview of the project and its setup) and the CONTRIBUTING.md file (for any project-specific contribution guidelines). Each repository may have slight variations in process or additional pointers for contributors. And of course, all contributors must adhere to our Code of Conduct ‚Äì be respectful and collaborative.
Standard Contribution Process
Most contributions will follow this standard workflow:
Find or Propose an Issue: Start by identifying what you want to contribute. If it‚Äôs a new bug or idea, you can open an issue to discuss it. Often, there will be existing issues labeled ‚ÄúWorkflow: Open to contribution‚Äù that are ready for community work‚Äã
GITHUB.COM
. These are a great starting point. Pick an open issue that interests you, or propose a new one and work with the Steering Committee to get it clarified and approved for work.
Discussion and Assignment: Once you‚Äôve found an issue to work on, comment on the issue to express your interest. For example: ‚ÄúI‚Äôd like to work on this. Could you assign it to me?‚Äù A Steering Committee member will then assign the issue to you if it‚Äôs appropriate‚Äã
GITHUB.COM
. Assignment is important to avoid duplicate work and to signal that you‚Äôre the owner of that task. At this stage, feel free to ask any clarifying questions about the expected solution or scope. The committee may provide initial guidance or link you to relevant documentation.
Set Up Your Development Environment: Follow the instructions in the README.md for setting up the project locally. Typically, you will need to fork the repository to your own GitHub account and then clone your fork. (If you are an internal NI developer or Steering Committee member with direct access, you might instead create a branch on the main repo. External contributors will use forks.) Make sure you can build and run tests if applicable.
Create a Feature Branch: Work on a dedicated branch for your contribution. If you‚Äôre working from a fork, create a new branch in your fork (e.g., username/feature-name). Some NI projects might automate the branch creation for you once you‚Äôre assigned‚Äã
GITHUB.COM
 (for example, a GitHub Action could create a branch in the main repo like feature/your-issue which you can then pull to your fork). However, if that‚Äôs not the case, simply create a branch on your own fork. Give it a descriptive name (and include the issue number if applicable).
Implement Your Changes: Code the feature or fix the bug according to the project‚Äôs coding standards. Try to keep the changes focused on the issue at hand. It‚Äôs a good practice to write or update unit tests if the project has tests, to ensure your change works as expected. For changes that affect the user, update documentation or examples if needed. You can ask for early feedback by opening a draft pull request or by discussing in the issue/Discord if you‚Äôre unsure about something.
Local Testing: Before submitting your work, run the project‚Äôs test suite and linters locally (if applicable). Ensure that all tests pass and that your code doesn‚Äôt introduce new warnings or style violations. This will save time during review. If the project provides a script or tool to build an artifact (for example, building a LabVIEW .vip package), you can try generating it locally to verify everything packages correctly‚Äã
GITHUB.COM
.
Open a Pull Request (PR): When you‚Äôre ready, open a pull request against the appropriate branch. In many cases, the PR should target the develop branch (or whichever branch is used for integration) rather than main directly, unless the project uses a different branching strategy. The repository‚Äôs CONTRIBUTING.md should clarify this. In the PR description, link to the issue number (e.g., ‚ÄúCloses #123‚Äù) and provide a brief summary of your changes. The PR template (if one is provided) will guide you to include necessary information. Opening a PR will trigger the CI pipeline automatically in most NI projects‚Äã
GITHUB.COM
.
Sign the Contributor License Agreement (CLA): If this is your first time contributing to an NI open source project, a CLA check will likely be in place. NI requires external contributors to sign a one-time Contributor License Agreement before we can merge your code‚Äã
GITHUB.COM
‚Äã
GITHUB.COM
. The CLA is usually a quick electronic agreement that verifies you are contributing code you have rights to and that you are okay with NI using it in their products under the project‚Äôs license. Follow the instructions provided (often a bot or CLA assistant will comment on your PR with a link). This is a critical step ‚Äì maintainers cannot merge your PR until the CLA is signed.
Automated CI Checks: Once your PR is open, our Continuous Integration (CI) system will run a series of checks. Typically, this includes building the project, running automated tests, and performing static analysis or linters. For example, if contributing to the LabVIEW Icon Editor, the CI will attempt to build a VI Package (.vip) and run any unit tests, ensuring your changes don‚Äôt break the build‚Äã
GITHUB.COM
. You don‚Äôt need to do anything here except wait for the results. If a check fails (perhaps a test breaks or a linter finds an issue), you‚Äôll need to address those and push an update to your branch. The CI helps maintainers verify that contributions are safe to merge.
Code Review: In parallel with CI, Steering Committee members will review your pull request. They might request changes or ask questions. This is a normal part of the process ‚Äì be prepared to iterate on your code. Common feedback might involve code style, architecture, performance implications, documentation, or alignment with the project‚Äôs goals. Our reviewers aim to be constructive and helpful. As a contributor, try to be receptive to feedback and engage in the discussion. The review is a collaborative conversation to improve the contribution. Once you‚Äôve made any requested updates, the reviewers will check again. Multiple rounds of review may occur for larger contributions ‚Äì this leads to a better end result.
Approval and Merge: After your contribution is approved by the necessary reviewers (often at least one or two Steering Committee members) and all CI checks are green, it‚Äôs time to merge. A Steering Committee member will handle the actual merging of the PR. Depending on the project‚Äôs workflow, they might merge into a develop branch first‚Äã
GITHUB.COM
, which accumulates changes for the next release, or they might merge directly to main if a simpler workflow is used. In a multi-branch model (like git-flow), your changes will eventually be merged from develop to main as part of a release. The exact mechanics aren‚Äôt too important for contributors ‚Äì what matters is your code is now part of the project! You‚Äôll get a notification once it‚Äôs merged. Congratulations üéâ and thank you for your contribution!
Post-Merge Follow-Up: After merging, your issue is closed (if it was linked properly, this happens automatically). You might want to pull the latest changes from the upstream repository to your fork‚Äôs main branch to keep in sync for future contributions. If your contribution was a significant change, keep an eye on any user feedback or issues that might be reported; you can help by responding or fixing follow-up issues. The Steering Committee might also invite you to continue contributing or even consider you for more responsibility if you‚Äôre interested.
Throughout this process, communication is key. Feel free to ask questions on the issue, on your PR, or in the project‚Äôs chat (some projects use a Discord or forum for quick questions). We want you to succeed and feel welcome. By following the workflow above, you help us maintain order and ensure every contribution lands safely. Also note that non-code contributions are highly valued. You don‚Äôt have to be a software developer to help. Testing pre-release builds and providing feedback, improving documentation, designing graphics, or helping other users in discussions are all meaningful contributions. Our community values these efforts just as much as code‚Äã
GITHUB.COM
, and the workflow for those (where applicable) is similar: open an issue or a PR, and a maintainer will engage with you.
Experimental Branches for Large Features
Sometimes, you may have an idea for a large feature or architectural change that can‚Äôt be developed and merged in a single short-lived pull request. For example, it might be a multi-month effort or something experimental that needs feedback as it progresses. In such cases, experimental branches are used. This is a special workflow for long-running development that still occurs under the project‚Äôs repository (rather than a personal fork) to maximize collaboration and CI support. Not every NI project will use this model, but for those that do (such as the LabVIEW Icon Editor), the process works like this:
Proposal and Approval: First, discuss your big idea with the Steering Committee. This could be done via a GitHub Discussion or an issue marked as a proposal. The committee will evaluate the idea‚Äôs scope, risks, and alignment with the project roadmap. If they agree it‚Äôs worth pursuing as an experiment, they will approve the creation of an experimental branch (often named experiment/<short-name>). The existence of an experimental branch means ‚Äúwe approve working on this feature publicly in the repo, but it‚Äôs not yet ready for integration into develop/main.‚Äù
Branch Creation: An NI maintainer (usually the Program Manager or a Steering Committee member from NI) will create the experimental branch in the repository on your behalf‚Äã
GITHUB.COM
. Typically, it branches off from the current develop or main branch. For example, experiment/improved-rendering could be created for a new rendering engine for the editor. Once created, you and any collaborators can clone and work on this branch similar to any other branch, except it lives in the main repo (giving you access to all the CI and tooling).
Development in the Experiment: You‚Äôll work on the experimental branch over a longer period. Multiple people can contribute to it (since it‚Äôs in the main repo, others can make PRs into the experimental branch if permitted). Regular commits and even intermediate pull requests can happen on this branch. The key difference is that this branch is isolated from the main development branch, so it won‚Äôt affect the stable code until it‚Äôs finished. You should periodically merge changes from the develop branch into your experimental branch to keep it up to date with the latest fixes and features in the project‚Äã
GITHUB.COM
. This avoids a huge merge conflict at the end.
Continuous Integration (CI) for Experiments: Just like any branch, the CI pipeline runs on experimental branch commits. All the usual tests and analyses will run (for instance, code scanning like CodeQL or custom analyzers)‚Äã
GITHUB.COM
. This ensures that even though it‚Äôs a long-lived branch, it adheres to quality and security standards throughout its development. However, one special safeguard is in place: automated package or artifact publishing is disabled for experimental branches. In other words, while CI might build your code and run tests, it will not produce a public release artifact (e.g., an installer or package) by default, because the work is preliminary. To get an installable build for testers, an NI team member must explicitly allow it (next point).
Approve-Experiment (CI Trigger): When your experimental branch reaches a point where you want to share a build (for example, an alpha version) with testers or the community, an NI maintainer can trigger a manual workflow event known as ‚Äúapprove-experiment‚Äù. This is a special CI job that, once manually invoked, will enable the generation of build artifacts for that experimental branch‚Äã
GITHUB.COM
‚Äã
GITHUB.COM
. NI uses this manual approval step as a checkpoint to ensure nothing sensitive or dangerously unstable will be widely distributed. Essentially, the Steering Committee and Program Manager will review the experiment‚Äôs status and code scans, and if everything looks okay, they hit the approve button. After that, CI might attach a built package (.vip or otherwise) to the branch‚Äôs workflow run or GitHub release for people to download and test. This approach ensures that potentially large-scale or risky features only get distributed when maintainers are confident in their safety and quality‚Äã
GITHUB.COM
.
Alpha/Beta Sub-branches (Optional): Within an experimental branch, you might further organize stages of development. Some projects allow creating sub-branches like experiment/feature/alpha, .../beta, or .../rc (release candidate)‚Äã
GITHUB.COM
. These can be used if you want to denote different testing phases of the experiment. For example, once core development is done on experiment/improved-rendering, you might branch off an experiment/improved-rendering/alpha for broader testing, then merge feedback, then promote to /beta, and so on. This is not strictly required, but it‚Äôs a way to manage complex rollouts. The CI and approval mechanism would treat these similarly (each might need separate artifact approvals, depending on setup).
Continuous Feedback: An experimental branch should be developed in the open just like any other work. The community and Steering Committee will be aware of its existence, and you‚Äôre encouraged to post updates, seek feedback, and even invite others to contribute. Because it‚Äôs in the main repo, everyone can see the work-in-progress. This transparency helps catch issues early and lets NI‚Äôs product teams keep an eye on progress‚Äã
GITHUB.COM
. Don‚Äôt hesitate to create draft PRs from the experiment branch back to develop just to solicit feedback on the diff (even if the PR isn‚Äôt meant to be merged yet). This way, by the time the feature is complete, most design questions have been settled.
Final Merge: When the experimental feature is deemed ready (it has met its goals, tests are passing, feedback is positive), the Steering Committee will plan to merge it back into the main development branch (usually develop). This is effectively the ‚Äúbig bang‚Äù merge where a long-lived branch comes back home‚Äã
GITHUB.COM
. Before doing this, the committee will do a comprehensive review of the entire feature. In some cases, they might invite additional reviewers or even NI domain experts to ensure the feature meets all requirements. The merge will likely be done via a pull request from experiment/<name> into develop, going through the normal PR review process. Given the size, it might take some time to review and test thoroughly. Once approved, it gets merged. At that point, the experiment branch is usually deleted or archived, and further work continues on the develop branch.
Partial or Abandoned Experiments: Not every experiment will conclude successfully. Some may turn out to be too difficult, or requirements might change, or a better approach is discovered. The bylaws allow for experiments to be terminated. If an experiment is not going to be merged, the Steering Committee will communicate this openly. They may choose to merge parts of the code that are useful, or simply document lessons learned. An abandoned experiment branch might be kept for reference but will eventually be cleaned up. The decision to halt an experiment is taken by the Steering Committee in consultation with the Program Manager, focusing on what‚Äôs best for the project‚Äôs long-term health.
If you are interested in the nitty-gritty details of how a specific project handles experimental branches, check that repository‚Äôs documentation. For example, see the EXPERIMENTS.md guide in the LabVIEW Icon Editor repository for an in-depth explanation‚Äã
GITHUB.COM
‚Äã
GITHUB.COM
. Not all projects will have an Experiments doc, but the general ideas remain the same. The existence of this workflow underscores NI‚Äôs commitment to supporting innovative, ambitious contributions without destabilizing the main codebase. It gives community members a chance to work on game-changing features under the safety net of CI and maintainer oversight.
Decision-Making Authority and Governance
NI‚Äôs open source projects operate under a model of collaborative governance. This means that while NI provides oversight and vision (especially for aligning with product goals), the community of contributors has a strong voice in day-to-day decisions. In practice, decision-making authority is shared between the Steering Committee and NI‚Äôs leadership (represented by the Program Manager or project lead). Here‚Äôs how governance and decisions play out:
Steering Committee Autonomy: The Steering Committee has authority over most technical and operational decisions in the project‚Äôs daily life. They collectively decide which contributions to accept, how to implement certain features, and how to prioritize issues. They use discussion and consensus-building to make decisions. For example, when a contributor proposes a change, the committee members will discuss its merits openly (on the issue or PR). If consensus is reached, they move forward. If there‚Äôs minor disagreement, they may refine the solution or compromise. The committee is trusted to use their best judgment in the interest of the project and its users.
Voting or Consensus: Many decisions are made by informal consensus ‚Äì if no one on the committee objects, a proposal is considered accepted. If there is disagreement on a significant matter (say, adopting a new dependency or changing a workflow), the committee might call a vote or a more structured decision process. Some governance documents (like a separate GOVERNANCE.md, if present) may outline specific voting procedures or quorum for certain decisions. In the absence of a formal process, the default is discussion until a general agreement or majority agreement is evident. Meeting notes or decision records may be kept for major decisions for transparency.
Major Changes and BDFL Override: For major roadmap decisions or directional changes, NI retains a final decision authority (often referred to as a ‚ÄúBDFL‚Äù ‚Äì Benevolent Dictator For Life ‚Äì role, though in a benevolent, minimal-interference way). As noted earlier, the Steering Committee handles day-to-day matters, but major calls remain with NI‚Äã
GITHUB.COM
. What counts as a ‚Äúmajor‚Äù decision? This could be anything that significantly impacts NI‚Äôs product strategy or requires substantial NI resources. Examples: deciding to deprecate a major feature that NI products rely on, changing the license of the project, or choosing to collaborate/merge with another NI project. In such cases, the NI Open Source Program Manager or an NI executive will make the final call, taking into account the Steering Committee‚Äôs input and the community‚Äôs needs. This is rarely invoked, and in practice NI usually follows the community‚Äôs lead unless there‚Äôs a compelling reason.
Transparent Governance: All decisions, whether minor or major, are made in a transparent manner. We avoid back-room decisions. If the Steering Committee discusses something privately (e.g., in a scheduled meeting or an NI-internal chat), they will bring the summary or outcome to the public forum (GitHub issue, discussion, or mailing list) so that the community is informed. Our governance model is intended to be public-facing. If you‚Äôre ever unsure why a decision was made, you should feel free to ask, and the committee will clarify the reasoning.
Dispute Resolution: In the event of a dispute or deadlock within the Steering Committee, the issue is escalated to the NI Program Manager. The Program Manager will work with the committee to find a resolution, aiming for a solution that balances community innovation with product requirements. If necessary, the Program Manager (as NI‚Äôs representative) has the authority to make the final decision to move forward. Again, this is a safeguard and not the normal mode of operation.
Evolving Governance: These bylaws and the composition of the Steering Committee can evolve over time. The community may propose changes to the governance model itself ‚Äì for example, adding a new committee seat for a frequent contributor, or formalizing a voting process. Changes to governance are usually discussed at length and require agreement from both the current committee and NI‚Äôs Program Manager, since they affect the project‚Äôs long-term structure. Any updates to this document or related governance docs will be done via the same contribution process (pull requests and reviews) so that everyone can weigh in.
Breadth of Steering Committee Oversight: Note that the Steering Committee‚Äôs oversight isn‚Äôt purely technical. They also look after the project‚Äôs well-being in other ways, like ensuring the Code of Conduct is enforced, mediating social issues, and managing knowledge (documentation, onboarding materials, etc.). In a sense, they ‚Äústeer‚Äù all aspects of the project‚Äôs open source life, not just the code. NI‚Äôs Open Source Program Manager supports them in these aspects but encourages the committee to take the lead in community-facing matters.
In summary, our governance is a blend of community-driven decision making with NI‚Äôs oversight on the horizon. We strive for a lightweight, collaborative approach where contributors feel ownership and agency, and NI feels confident that the project will meet its larger goals. This balance is what makes the NI open source initiative sustainable and rewarding for all parties.
CI/CD Integration and Release
Continuous Integration and Continuous Deployment (CI/CD) are integral to how NI open source projects maintain quality and deliver updates. We integrate CI/CD pipelines into our GitHub repositories to automate testing, building, and in some cases releasing new versions. Contributors should be aware of how CI affects their work and how their contributions eventually become part of a release. This section covers how CI/CD is woven into the process:
Automated Testing for Every Contribution: Every pull request triggers an automated build and test process via GitHub Actions or a similar CI service. This ensures that each contribution is validated in a consistent environment. For example, the CI may compile the code, run unit tests across supported platforms, and perform static code analysis (like linting or security scans). This consistency catches issues early and frees contributors from having to manually run full test suites on their own. It also means that if your contribution inadvertently breaks something, we‚Äôll catch it before merging. Our motto is ‚Äúno broken main branch‚Äù ‚Äì the main codebase should always be in a releasable state, thanks to CI. In practice, CI provides confidence and immediate feedback on your PR‚Äã
GITHUB.COM
.
Quality Gates: The CI is configured with certain ‚Äúgates‚Äù that a contribution must pass. These gates could include: all tests passing, code coverage not dropping below a threshold, static analysis finding no critical issues, and formatting checks passing. If any of these gates fail, the CI will mark the pull request as failing. Maintainers will generally not merge a PR until all required checks are green (unless there‚Äôs a very good reason and an override is used, which is extremely rare). As a contributor, you might need to iterate on your code to fix CI failures. This is a normal part of development ‚Äì even maintainers encounter their own CI failures and fix them! The CI logs are available on the PR page, and you can ask for help if something is unclear.
Building Artifacts: Many NI projects produce distributable artifacts as part of CI. For instance, the LabVIEW Icon Editor builds a .vip package (VI Package) from the source code. Other projects might produce DLLs, npm packages, Docker images, etc., depending on the technology. Our CI pipelines are set up to create these build artifacts automatically whenever changes are merged, and sometimes even for each PR (as a preview build). For security reasons, preview artifacts might be available only to NI or attached to GitHub Actions runs, whereas official release artifacts are attached to GitHub Releases. In any case, this automation means that after your contribution is merged, it will be included in the next build artifact without manual intervention. Contributors and users can download these artifacts to test the latest changes easily.
Versioning and Releases: NI open source projects typically follow semantic versioning for releases, and CI can assist with this. For example, some repositories use labels on pull requests like bump:minor or bump:patch to indicate the next version increment, and the CI will automatically update version numbers and changelogs upon merge. When it‚Äôs time to cut a new release, the maintainers will merge develop into main (if using a two-branch model) and tag a release. The CI will then create a GitHub Release with release notes and attach the built artifacts. This could even be triggered by a workflow dispatch or by simply pushing a tag. The key point is that releases are streamlined ‚Äì once the code is in the main branch, making a new official release is largely automated and quick. This encourages frequent, incremental releases so that users can benefit from contributions sooner.
Integration with NI Product Builds: A special aspect of NI‚Äôs open source projects is that some of them feed directly into NI‚Äôs proprietary product build processes. For example, when NI builds the next version of LabVIEW, it pulls in the latest code from the open source repository (at a specific commit or tag) to include, say, the updated Icon Editor‚Äã
GITHUB.COM
. CI helps ensure that what‚Äôs in the main branch is always production-ready. Additionally, our CI might run tests that simulate the integration (for instance, verifying that an open source component works within a LabVIEW environment). If your project is one that gets integrated, the maintainers will communicate how and when that synchronization happens (it could be at certain release tags or continuous). As a contributor, you don‚Äôt have to do anything special for this; just know that the stakes can be high ‚Äì your contribution, once released, could be used by thousands of NI customers worldwide. The CI and review process is designed to uphold the quality needed for that level of impact.
Special Workflows (Security, Docs, etc.): In addition to build-and-test, our CI might include workflows for security scanning (e.g., GitHub‚Äôs CodeQL or dependency scanning), documentation publishing (maybe generating a docs site or PDF from markdown), and other maintenance tasks. These typically run on a schedule or when specific files change. They generally don‚Äôt require contributor involvement but are part of the project‚Äôs health. If a security scan flags something related to your contribution, maintainers will discuss it with you to address it. We mention this to highlight that CI/CD is not just about tests, but a variety of automations that keep the project robust.
CI for Experimental Branches: We covered experimental branches earlier ‚Äì note that those branches also benefit from CI. They run tests and scans like any other branch‚Äã
GITHUB.COM
, but with the aforementioned restriction on releasing artifacts until approved‚Äã
GITHUB.COM
. This ensures experiments maintain code hygiene and can be merged with confidence later. If you are working on an experiment, treat the CI with equal importance; a green build there is just as crucial.
Continuous Deployment (if applicable): Some smaller NI open source projects or libraries might even practice continuous deployment, where every merge to main automatically publishes an update (for example, publishing a package to a package manager). The governance around this will vary by project. In most cases, NI projects are a bit more controlled (preferring manual release approval), but the tooling is in place to automate deployment when desired. If you become a long-term contributor or maintainer, you might be involved in drafting release notes or pressing the ‚Äúrelease‚Äù button ‚Äì but that‚Äôs beyond the scope of a new contributor‚Äôs concern.
Overall, our CI/CD integration is about safety, speed, and reliability. It should give you confidence that if your change passes CI and is merged, it won‚Äôt unexpectedly break something else. It also means the burden of building and releasing isn‚Äôt on any one person‚Äôs shoulders ‚Äì it‚Äôs a repeatable process the system handles. We continuously monitor our CI results and invest in improving the coverage and quality of tests. If you spot a gap (like a test that should exist but doesn‚Äôt), feel free to contribute that as well! Every test makes the project more stable for everyone. In practical terms for contributors: pay attention to CI results on your PR, and feel free to ask if you need help interpreting a failure. Once your PR is merged, you can celebrate ‚Äì our CI will take care of the rest, and your code will be on its way to users.
Community Expectations and Code of Conduct
Our community is the heart of the NI Open Source Initiative. We strive to maintain a welcoming, inclusive, and professional environment for all participants. Whether you are a seasoned NI engineer, a volunteer contributor, or a curious first-timer, you are expected to interact with respect and kindness. To set clear standards for behavior, all NI open source projects adopt a Code of Conduct (based on the Contributor Covenant). We encourage everyone to read the CODE_OF_CONDUCT.md in this repository for the full details. Here are the key expectations for community behavior:
Be Respectful and Inclusive: Treat everyone with respect. Disagreements and debates about ideas are fine, but personal attacks or derogatory language are not acceptable. We welcome contributions from people of all backgrounds and skill levels. Embrace diversity of thought and experience ‚Äì it makes the project stronger.
Collaborative Communication: Communicate openly and constructively. When you critique code or ideas, do it with the aim of improvement, not to disparage. Likewise, if someone critiques your work, try not to take it personally. We‚Äôre all here to make the software better. Avoid sarcasm or tone that could be misinterpreted in text. If something isn‚Äôt clear, ask for clarification rather than assuming the worst.
Follow Project Guidelines: Adhering to the processes (like these bylaws, the contributing guide, issue templates, etc.) is also part of respectful behavior. It shows respect for maintainers‚Äô time and the community‚Äôs norms. For example, don‚Äôt bypass the review process or try to pressure maintainers to merge your PR. Understand that everyone is doing this voluntarily and in good faith.
Zero Tolerance for Harassment: Harassment, bullying, discrimination, or any kind of inappropriate behavior will not be tolerated. This includes not just obvious cases like insults or slurs, but also subtle stuff like unwelcome sexual attention or stalking, and especially any behavior that makes someone feel unsafe or excluded. If you‚Äôre asked to stop a certain behavior, stop immediately.
Reporting Issues: If you encounter behavior that violates the Code of Conduct, please report it. Usually, the Code of Conduct file will list a contact (often an email or a specific person, like the Open Source Program Manager) to report concerns to. In this project, you can contact the NI Open Source Program Manager or the email listed in the Code of Conduct to report harassment or other misconduct. All reports will be taken seriously and handled confidentially. The Steering Committee and NI will work together to investigate and act on any violations, which may include warnings or removal from the community or project.
Encouraging a Positive Environment: Beyond just avoiding negatives, we encourage positive reinforcement. Thank fellow contributors and maintainers. Celebrate releases and good work. Help newcomers by answering their questions kindly. We want contributing to be a fun and rewarding experience. NI often publicly acknowledges significant contributors (for example, in release notes or blogs), and being a supportive community member is as important as writing good code.
By participating in this project, you agree to abide by these standards. This isn‚Äôt just boilerplate ‚Äì NI and the Steering Committee are committed to enforcing the Code of Conduct to maintain a healthy community. We believe that great technology is built by great communities, and that means everyone feels comfortable and respected. If you‚Äôre new, don‚Äôt be anxious ‚Äì our guidelines are simply about being a decent human being. If you make a mistake (for example, a comment that came off a bit harsh), it‚Äôs usually okay ‚Äì someone will gently remind you of the expected tone. We all learn and grow together. The main point is: when in doubt, be kind. You can find more details and the exact language of our community standards in the Code of Conduct. Thank you for helping us make this a welcoming place for collaboration!
Conclusion and Encouragement
Thank you for reading the NI Open Source Initiative Bylaws. By now, you should have a clear picture of how our open source projects operate ‚Äì from the people involved and their roles, to the workflow that turns ideas into reality, to the tools and rules that ensure everything runs smoothly. We covered a lot of ground, but the essence is simple: we invite you to collaborate with us, and we‚Äôve put in place a structure to make that collaboration effective and enjoyable for everyone. Here are a few final takeaways:
You Belong Here: Whether you are fixing a typo or implementing a major feature, you are an important part of the project. Our governance model is designed to give you agency and support. If something in the process is unclear, just ask ‚Äì we‚Äôre here to help.
Your Work Matters: Contributions don‚Äôt disappear into a void; they become part of tools and products used by engineers and scientists worldwide. NI is committed to leveraging community contributions. That means your pull request could be in the next software update that NI ships to its customers‚Äã
GITHUB.COM
. We find that exciting, and we hope you do too! It‚Äôs a chance to leave your mark on NI‚Äôs ecosystem.
Collaboration is Key: These bylaws emphasize working together ‚Äì with respect, with transparency, and with shared purpose. If you‚Äôve never worked on open source before, don‚Äôt worry. Follow the guidelines, watch how the Steering Committee operates, and you‚Äôll get the hang of it. We all started somewhere, and this project is a great place to learn and grow.
Long-Term Vision: NI is in this for the long haul. The open source initiative isn‚Äôt a one-off experiment; it‚Äôs a core part of how we innovate. We are investing in community-driven development because we believe it leads to better outcomes for everyone. By contributing, you‚Äôre not only writing code or documentation ‚Äì you‚Äôre shaping the future of NI‚Äôs tools and perhaps influencing industry practices. That‚Äôs something to be proud of.
Stay in Touch: Don‚Äôt hesitate to join the conversation. Many of our projects have a community chat (like a Discord server or forum) where you can interact with NI engineers and fellow contributors in real time. These are great venues for brainstorming, quick questions, or just getting to know the team. And of course, our GitHub issues and discussion boards are always open for your ideas and feedback.
In conclusion, we‚Äôd like to thank you for considering contributing to an NI open source project. These bylaws are here to ensure we all have a common understanding and can work together effectively. They are meant to empower you with knowledge of how things work. We believe that with these foundations, we can collaborate in a way that‚Äôs both fun and highly productive. Now, let‚Äôs get started ‚Äì check out the issues, fork the repo, and make something awesome! If you‚Äôre ever unsure about anything, refer back to this guide, the project‚Äôs documentation, or reach out to the maintainers. We look forward to your contributions and to advancing the state of the art together. Happy contributing! üéâ <!-- Citations for reference (do not remove these): :contentReference[oaicite:35]{index=35} ‚Äì LabVIEW Icon Editor CONTRIBUTING.md (Introduction; explains contributions appear in LabVIEW releases) :contentReference[oaicite:36]{index=36} ‚Äì LabVIEW Icon Editor CONTRIBUTING.md (Contributing Philosophy; SC vs BDFL roles) :contentReference[oaicite:37]{index=37} ‚Äì LabVIEW Icon Editor CONTRIBUTING.md (CLA requirement and purpose) :contentReference[oaicite:38]{index=38} ‚Äì LabVIEW Icon Editor EXPERIMENTS.md (manual ‚Äúapprove-experiment‚Äù workflow for artifacts) :contentReference[oaicite:39]{index=39} ‚Äì LabVIEW Icon Editor README.md (Steering Committee reviews PRs, ensures tests pass before merging) :contentReference[oaicite:40]{index=40} ‚Äì LabVIEW Icon Editor CONTRIBUTING.md (Steering Committee composition and ‚ÄúOpen to contribution‚Äù labeling) :contentReference[oaicite:41]{index=41} ‚Äì LabVIEW Icon Editor CONTRIBUTING.md (Assigning issues to contributors) :contentReference[oaicite:42]{index=42} ‚Äì LabVIEW Icon Editor README.md (Experimental branch workflow bullet points) :contentReference[oaicite:43]{index=43} ‚Äì LabVIEW Icon Editor EXPERIMENTS.md (Key concepts: experiment branch, scans, manual approval, etc.) :contentReference[oaicite:44]{index=44} ‚Äì LabVIEW Icon Editor CI-Workflows.md (Benefits of CI automation for consistency) :contentReference[oaicite:45]{index=45} ‚Äì LabVIEW Icon Editor CONTRIBUTING.md (Opening a PR triggers CI, CLA reminder) :contentReference[oaicite:46]{index=46} ‚Äì LabVIEW Icon Editor CONTRIBUTING.md (Feature branch, fork & clone, implement & test, open PR, CI builds .vip) :contentReference[oaicite:47]{index=47} ‚Äì LabVIEW Icon Editor CONTRIBUTING.md (Value of non-code contributions equally to code) -->
