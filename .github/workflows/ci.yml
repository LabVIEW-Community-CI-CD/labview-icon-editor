name: CI Pipeline

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

on:
  push:
    branches:
      - main
      - develop
      - release/*
      - feature/*
      - hotfix/*
  pull_request:
    branches:
      - main
      - develop
      - release/*
      - feature/*
      - hotfix/*
    types:
      - opened
      - synchronize
      - reopened
      - ready_for_review
  workflow_dispatch:

jobs:
  prepare:
    name: Prepare Workspace
    runs-on: self-hosted-windows-lv
    steps:
      - name: Check out code (full depth, clean)
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          clean: true
          persist-credentials: true
      - name: Trust repo folder (Git safe.directory)
        shell: pwsh
        run: git config --global --add safe.directory "$Env:GITHUB_WORKSPACE"

  version:
    name: Compute Version
    needs: prepare
    runs-on: self-hosted-windows-lv
    outputs:
      VERSION:       ${{ steps.next_version.outputs.VERSION }}
      MAJOR:         ${{ steps.next_version.outputs.MAJOR }}
      MINOR:         ${{ steps.next_version.outputs.MINOR }}
      PATCH:         ${{ steps.next_version.outputs.PATCH }}
      BUILD:         ${{ steps.inc_build.outputs.new_build_number }}
      IS_PRERELEASE: ${{ steps.next_version.outputs.IS_PRERELEASE }}
    steps:
      - name: Determine bump type
        id: bump_type
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            let bump = 'none';
            if (context.event_name === 'pull_request') {
              const labels = context.payload.pull_request.labels.map(l => l.name.toLowerCase());
              if (labels.includes('major')) bump = 'major';
              else if (labels.includes('minor')) bump = 'minor';
              else if (labels.includes('patch')) bump = 'patch';
            }
            core.setOutput('bump_type', bump);

      - name: Determine build number
        id: inc_build
        shell: pwsh
        run: |
          git fetch --unshallow 2>$null || Write-Host "Already a full clone."
          $count = git rev-list --count HEAD
          Write-Host "Commit-based build number => $count"
          "new_build_number=$count" | Out-File -FilePath $Env:GITHUB_OUTPUT -Append

      - name: Compute version string
        id: next_version
        shell: pwsh
        env:
          BUMP_TYPE:    ${{ steps.bump_type.outputs.bump_type }}
          BUILD_NUMBER: ${{ steps.inc_build.outputs.new_build_number }}
        run: |
          $latest = (git describe --tags --abbrev=0 2>$null).TrimStart('v') -replace '-build.*'
          if (-not $latest) { $maj=0; $min=0; $pat=0 } else { $maj,$min,$pat = $latest.Split('.') }
          switch ($env:BUMP_TYPE) {
            'major' { $maj++; $min=0; $pat=0 }
            'minor' { $min++; $pat=0 }
            'patch' { $pat++ }
          }
          $branch = $Env:GITHUB_REF -replace '^refs/heads/',''
          $suffix = ''
          if ($branch -like 'release-alpha/*') { $suffix = "alpha.$($Env:BUILD_NUMBER)" }
          elseif ($branch -like 'release-beta/*')  { $suffix = "beta.$($Env:BUILD_NUMBER)" }
          elseif ($branch -like 'release-rc/*')    { $suffix = "rc.$($Env:BUILD_NUMBER)" }
          $version = if ($suffix) { "v$maj.$min.$pat-$suffix-build$($Env:BUILD_NUMBER)" } else { "v$maj.$min.$pat-build$($Env:BUILD_NUMBER)" }
          $isPre  = if ($suffix) { 'true' } else { 'false' }
          Write-Host "Computed version => $version"
          "VERSION=$version"      | Out-File -FilePath $Env:GITHUB_OUTPUT -Append
          "MAJOR=$maj"            | Out-File -FilePath $Env:GITHUB_OUTPUT -Append
          "MINOR=$min"            | Out-File -FilePath $Env:GITHUB_OUTPUT -Append
          "PATCH=$pat"            | Out-File -FilePath $Env:GITHUB_OUTPUT -Append
          "IS_PRERELEASE=$isPre"  | Out-File -FilePath $Env:GITHUB_OUTPUT -Append

  apply-deps:
    name: Apply VIPC Dependencies
    needs: prepare
    runs-on: self-hosted-windows-lv
    strategy:
      matrix:
        include:
          - lv-version: "2021"
            bitness: "32"
          - lv-version: "2021"
            bitness: "64"
          - lv-version: "2023"
            bitness: "64"
    steps:
      - name: Checkout for VIPC
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          clean: true
          persist-credentials: true

      - name: Apply VIPC for ${{ matrix['lv-version'] }} (${{ matrix.bitness }}-bit)
        uses: ./.github/actions/apply-vipc
        with:
          minimum_supported_lv_version: ${{ matrix['lv-version'] }}
          vip_lv_version:               ${{ matrix['lv-version'] }}
          supported_bitness:            ${{ matrix.bitness }}
          relative_path:                ${{ github.workspace }}
          scripts_folder:               "${{ github.workspace }}/pipeline/scripts"
          vipc_path:                    "Tooling/deployment/runner_dependencies.vipc"

      - name: Summarize VIPC
        shell: pwsh
        run: |
          Add-Content -Path $Env:GITHUB_STEP_SUMMARY -Value "- $(${{ matrix['lv-version'] }}) ($(${{ matrix.bitness }})-bit)"

  missing-in-project-check:
    name: Test Missingâ€‘Inâ€‘Project Action on Windows
    needs: apply-deps
    runs-on: self-hosted-windows-lv
    strategy:
      fail-fast: false
      matrix:
        lv-version: ["2021"]
        bitness:    ["64","32"]
    steps:
      - name: Check out code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Find .lvproj file
        id: find_proj
        shell: pwsh
        run: |
          $proj = Get-ChildItem -Path $PWD -Filter *.lvproj |
                  Select-Object -First 1 -ExpandProperty FullName
          if (-not $proj) {
            Write-Error 'No .lvproj file found in repo root'
            exit 1
          }
          Write-Host "ðŸ” Found project file: $proj"
          "project_file=$proj" >> $env:GITHUB_OUTPUT

      - name: Missingâ€¯Inâ€¯Project
        id: mip
        uses: ./.github/actions/missing-in-project
        with:
          lv-ver:       ${{ matrix.lv-version }}
          arch:         ${{ matrix.bitness }}
          project-file: ${{ steps.find_proj.outputs.project_file }}

      - name: Summarize to run â€œSummaryâ€ tab
        if: always()
        shell: pwsh
        env:
          PROJ_FILE: ${{ steps.find_proj.outputs.project_file }}
        run: |
          echo "â„¹ï¸  Using project file: $env:PROJ_FILE" >> $GITHUB_STEP_SUMMARY

          $artifact = 'missing-files.txt'
          if (Test-Path $artifact) {
            echo "### âŒ Missing files for ${{ matrix.lv-version }}â€‘${{ matrix.bitness }}" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            Get-Content $artifact -Raw | ForEach-Object { echo $_ } >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
          } else {
            echo "âœ… Nothing missing for ${{ matrix.lv-version }}â€‘${{ matrix.bitness }}" >> $GITHUB_STEP_SUMMARY
          }

      - name: Upload missingâ€‘files artifact
        if: always() && steps.mip.outputs.passed != 'True'
        uses: actions/upload-artifact@v4
        with:
          name: missing-files-${{ matrix.lv-version }}-${{ matrix.bitness }}
          path: missing-files.txt

  test:
    name: Run Unit Tests
    needs: [prepare, apply-deps, missing-in-project-check]
    runs-on: ${{ matrix.os == 'windows' && 'self-hosted-windows-lv' || 'self-hosted-linux-lv' }}
    strategy:
      matrix:
        os: [windows]
        lv-version: ["2021"]
        bitness: ["64","32"]
      fail-fast: false
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Run unit tests
        shell: pwsh
        working-directory: pipeline/scripts
        run: .\RunUnitTests.ps1 -MinimumSupportedLVVersion ${{ matrix['lv-version'] }} -SupportedBitness ${{ matrix.bitness }}
      - name: Summarize test results
        if: always()
        shell: pwsh
        working-directory: pipeline/scripts
        run: |
          $r=".\UnitTestReport.xml"; if (Test-Path $r) {
            [xml]$x=Get-Content $r
            $c=$x.SelectNodes('//testcase')
            if ($c) {
              $m="## LabVIEW Unit Test Results`n|Name|Class|Status|Time(s)|Assertions|`n|---|---|---|---|---|`n"
              foreach($i in $c){ $m+="|$($i.name)|$($i.classname)|$($i.status)|$($i.time)|$($i.assertions)|`n" }
              Add-Content -Path $Env:GITHUB_STEP_SUMMARY -Value $m
            }
          }

  build-package:
    name: Build VI Package
    needs: [version, test, apply-deps]
    runs-on: self-hosted-windows-lv
    permissions:
      contents:       write
      issues:         read
      pull-requests:  read
    env:
      MAJOR:                     ${{ needs.version.outputs.MAJOR }}
      MINOR:                     ${{ needs.version.outputs.MINOR }}
      PATCH:                     ${{ needs.version.outputs.PATCH }}
      BUILD:                     ${{ needs.version.outputs.BUILD }}
      COMMIT:                    ${{ github.sha }}
      DRAFT_RELEASE:             true
      USE_AUTO_NOTES:            true
      DISABLE_GPG_ON_FORKS:      false
      ATTACH_ARTIFACTS_TO_RELEASE: true
    steps:
      - name: Checkout code (clean, full depth)
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          clean: true

      - name: Trust repository folder (Git safe.directory)
        shell: pwsh
        run: git config --global --add safe.directory "$Env:GITHUB_WORKSPACE"

      - name: Possibly disable GPG signing on forks
        if: ${{ env.DISABLE_GPG_ON_FORKS == 'true' }}
        id: disable_signing
        shell: pwsh
        run: |
          if ("${{ github.repository }}" -ne "ni/labview-icon-editor") {
            $oldCommit = git config --global --get commit.gpgsign || ''
            $oldTag    = git config --global --get tag.gpgsign    || ''
            echo "old_commit_gpgsign=$oldCommit" >> $Env:GITHUB_OUTPUT
            echo "old_tag_gpgsign=$oldTag"       >> $Env:GITHUB_OUTPUT
            git config --global commit.gpgsign false
            git config --global tag.gpgsign    false
          }

      - name: Build the icon editor VI package
        shell: pwsh
        run: |
          $repoRoot      = $Env:GITHUB_WORKSPACE
          $scriptsFolder = Join-Path $repoRoot 'pipeline/scripts'
          $org, $repo    = $Env:GITHUB_REPOSITORY -split '/'
          & .\pipeline\scripts\Build.ps1 `
            -RelativePath        $repoRoot `
            -AbsolutePathScripts $scriptsFolder `
            -Major               $Env:MAJOR `
            -Minor               $Env:MINOR `
            -Patch               $Env:PATCH `
            -Build               $Env:BUILD `
            -Commit              $Env:COMMIT `
            -CompanyName         $org `
            -AuthorName          $repo

      - name: Create & push tag
        if: ${{ github.event_name != 'pull_request' }}
        shell: pwsh
        run: |
          $VERSION = "${{ needs.version.outputs.VERSION }}"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a $VERSION -m "Auto-tag by CI for $VERSION"
          git push origin $VERSION

      - name: Create GitHub Release
        if: ${{ success() && github.event_name != 'pull_request' }}
        id: create_release
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const versionTag = '${{ needs.version.outputs.VERSION }}';
            const draftRelease = (process.env.DRAFT_RELEASE || 'true').toLowerCase() === 'true';
            const useAutoNotes = (process.env.USE_AUTO_NOTES || 'true').toLowerCase() === 'true';
            const isPrerelease = (('${{ needs.version.outputs.IS_PRERELEASE }}' || '').toLowerCase() === 'true');
            const createParams = {
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: versionTag,
              name: versionTag,
              draft: draftRelease,
              prerelease: isPrerelease
            };
            if (useAutoNotes) { createParams.generate_release_notes = true; }
            else { createParams.body = "Reference local release notes or embed within .vip."; }
            const response = await github.rest.repos.createRelease(createParams);
            core.setOutput("release_id", response.data.id);

      - name: Attach .vip file(s) to Release
        if: ${{ success() && env.ATTACH_ARTIFACTS_TO_RELEASE == 'true' && github.event_name != 'pull_request' }}
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');
            const releaseId = parseInt('${{ steps.create_release.outputs.release_id }}', 10);
            const vipDir = path.join(process.env.GITHUB_WORKSPACE, 'builds', 'VI Package');
            for (const vipFile of fs.readdirSync(vipDir).filter(f => f.endsWith('.vip'))) {
              const data = fs.readFileSync(path.join(vipDir, vipFile));
              await github.rest.repos.uploadReleaseAsset({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: releaseId,
                name: vipFile,
                data,
                headers: { 'content-type': 'application/octet-stream' }
              });
            }
