name: Build VI Package

on:
  push:
    branches:
      - main
      - develop
      - release/*
      - hotfix/*
  pull_request:
    branches:
      - main
      - develop
      - release/*
      - hotfix/*
  workflow_dispatch:

env:
  DRAFT_RELEASE: true
  USE_AUTO_NOTES: true
  # (R9) Disable GPG signing on forks (set to 'true' if you want the step to run)
  DISABLE_GPG_ON_FORKS: false
  # (R5) Whether to attach the .vip to the release (set to 'true' if desired)
  ATTACH_ARTIFACTS_TO_RELEASE: true

jobs:
  build-release:
    # Requires a self-hosted runner with the "iconeditor" label
    runs-on: [self-hosted, iconeditor]
    permissions:
      contents: write
      issues: read
      pull-requests: read

    steps:
      ########################################################################
      # A) Possibly disable GPG signing on forks
      ########################################################################
      - name: Possibly disable GPG signing on forks
        if: ${{ env.DISABLE_GPG_ON_FORKS == 'true' }}
        id: disable_signing
        shell: pwsh
        run: |
          if ("${{ github.repository }}" -ne "ni/labview-icon-editor") {
            Write-Host "Detected a fork; disabling GPG signing..."
            $currentCommitGpgsign = git config --global commit.gpgsign
            if (-not $currentCommitGpgsign) { $currentCommitGpgsign = "" }

            $currentTagGpgsign = git config --global tag.gpgsign
            if (-not $currentTagGpgsign) { $currentTagGpgsign = "" }

            "old_commit_gpgsign=$currentCommitGpgsign" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            "old_tag_gpgsign=$currentTagGpgsign"       | Out-File -FilePath $env:GITHUB_OUTPUT -Append

            git config --global commit.gpgsign false
            git config --global tag.gpgsign false
          } else {
            Write-Host "This is the official repo => no GPG changes."
            "old_commit_gpgsign=" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            "old_tag_gpgsign="    | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          }

      ########################################################################
      # 1) Check out code (full depth)
      ########################################################################
      - name: Check out code
        uses: actions/checkout@v3
        with:
          persist-credentials: true
          fetch-depth: 0

      ########################################################################
      # 2) Determine bump type from labels (major/minor/patch), else none
      ########################################################################
      - name: Determine bump type
        id: bump_type
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            if (context.event_name === 'pull_request') {
              const labels = context.payload.pull_request.labels.map(l => l.name.toLowerCase());
              core.info(`Found labels on PR: ${labels.join(', ')}`);

              let bump = 'none';
              if (labels.includes('major')) {
                bump = 'major';
              } else if (labels.includes('minor')) {
                bump = 'minor';
              } else if (labels.includes('patch')) {
                bump = 'patch';
              }
              core.setOutput('bump_type', bump);
            } else {
              // For direct pushes, default to 'none'
              core.setOutput('bump_type', 'none');
            }

      ########################################################################
      # 3) Commit-based build number
      ########################################################################
      - name: Determine build number
        id: inc_build
        shell: pwsh
        run: |
          git fetch --unshallow 2>$null || Write-Host "Already full clone."
          $commitCount = git rev-list --count HEAD
          Write-Host "Commit-based build number => $commitCount"
          "new_build_number=$commitCount" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      ########################################################################
      # 4) Parse latest version tag, apply major/minor/patch if found
      ########################################################################
      - name: Compute version string
      id: next_version
      shell: pwsh
      env:
        BUMP_TYPE: ${{ steps.bump_type.outputs.bump_type }}
        BUILD_NUMBER: ${{ steps.inc_build.outputs.new_build_number }}
      run: |
        Write-Host "Bump type: $($env:BUMP_TYPE)"
        Write-Host "Build number: $($env:BUILD_NUMBER)"
    
        # 1) Find the last stable tag
        #    If no tags found, default to v0.0.0
        $latestTag = git describe --tags --abbrev=0 2>$null
        if ([string]::IsNullOrEmpty($latestTag)) {
          $baseMajor = 0
          $baseMinor = 0
          $basePatch = 0
        }
        else {
          # e.g. if $latestTag is v1.2.3-build45, remove the prefix and any -build
          $tagNoPrefix = $latestTag.TrimStart('v')
          $versionPart = $tagNoPrefix -replace '-build.*',''
          $baseMajor, $baseMinor, $basePatch = $versionPart.Split('.')
        }
    
        $newMajor = [int]$baseMajor
        $newMinor = [int]$baseMinor
        $newPatch = [int]$basePatch
    
        # 2) Apply label-based semantic bump: major, minor, patch, or none
        switch ($env:BUMP_TYPE) {
          'major' {
            $newMajor++
            $newMinor = 0
            $newPatch = 0
          }
          'minor' {
            $newMinor++
            $newPatch = 0
          }
          'patch' {
            $newPatch++
          }
          'none' {
            # do nothing; rely on build number only
          }
        }
    
        # 3) Check for ALPHA / BETA / RC suffix
        #    We'll parse branch name to detect multiple channels.
        $branchName = $env:GITHUB_REF -split '/' | Select-Object -Last 1
        $preSuffix = ""
    
        # For example:
        #   release-alpha/* => -alpha.<N>
        #   release-beta/*  => -beta.<N>
        #   release-rc/*    => -rc.<N>
    
        if ($branchName -like 'release-alpha/*') {
          # Count commits or do something to produce alpha.<N>
          $commitsCount = git rev-list --count HEAD 2>$null
          if ([string]::IsNullOrEmpty($commitsCount)) { $commitsCount = 1 }
          $preSuffix = "alpha.$commitsCount"
        }
        elseif ($branchName -like 'release-beta/*') {
          $commitsCount = git rev-list --count HEAD 2>$null
          if ([string]::IsNullOrEmpty($commitsCount)) { $commitsCount = 1 }
          $preSuffix = "beta.$commitsCount"
        }
        elseif ($branchName -like 'release-rc/*') {
          $commitsCount = git rev-list --count HEAD 2>$null
          if ([string]::IsNullOrEmpty($commitsCount)) { $commitsCount = 1 }
          $preSuffix = "rc.$commitsCount"
        }
        # If none of these, it's presumably a final release or a standard branch (main, develop, etc.)
    
        # 4) Construct final version
        if ([string]::IsNullOrEmpty($preSuffix)) {
          # final version
          $version = "v$($newMajor).$($newMinor).$($newPatch)-build$($env:BUILD_NUMBER)"
          $isPrerelease = "false"
        }
        else {
          # pre-release
          $version = "v$($newMajor).$($newMinor).$($newPatch)-$preSuffix-build$($env:BUILD_NUMBER)"
          $isPrerelease = "true"
        }
    
        Write-Host "Computed version => $version"
        "VERSION=$version"         | Out-File -FilePath $env:GITHUB_OUTPUT -Append
        "IS_PRERELEASE=$isPrerelease" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
        "MAJOR=$newMajor"          | Out-File -FilePath $env:GITHUB_OUTPUT -Append
        "MINOR=$newMinor"          | Out-File -FilePath $env:GITHUB_OUTPUT -Append
        "PATCH=$newPatch"          | Out-File -FilePath $env:GITHUB_OUTPUT -Append
    

      ########################################################################
      # 5) Build the icon editor VI package, passing correct param set
      ########################################################################
      - name: Build the icon editor VI package
        shell: pwsh
        env:
          MAJOR: ${{ steps.next_version.outputs.MAJOR }}
          MINOR: ${{ steps.next_version.outputs.MINOR }}
          PATCH: ${{ steps.next_version.outputs.PATCH }}
          BUILD: ${{ steps.inc_build.outputs.new_build_number }}
          COMMIT: ${{ github.sha }}
        run: |
          $repoRoot      = $env:GITHUB_WORKSPACE
          $scriptsFolder = Join-Path $repoRoot 'pipeline/scripts'

          Write-Host "Building VI package => MAJOR=$($env:MAJOR), MINOR=$($env:MINOR), PATCH=$($env:PATCH), BUILD=$($env:BUILD)"

          .\pipeline\scripts\Build.ps1 `
            -RelativePath        $repoRoot `
            -AbsolutePathScripts $scriptsFolder `
            -Major               $env:MAJOR `
            -Minor               $env:MINOR `
            -Patch               $env:PATCH `
            -Build               $env:BUILD `
            -Commit              $env:COMMIT

          # The .vip file is now in builds/VI Package/*.vip

      ########################################################################
      # 6) Capture the .vip file path as a step output => source of truth
      ########################################################################
      - name: Discover .vip path
        id: find_vip
        shell: pwsh
        run: |
          $vipFile = Get-ChildItem -Path "builds/VI Package" -Filter "*.vip" -ErrorAction Stop | Select-Object -First 1
          if (-not $vipFile) {
            Write-Host "No .vip file found in builds/VI Package!"
            exit 1
          }
          Write-Host "Discovered VIP File: $($vipFile.FullName)"
          "vip_path=$($vipFile.FullName)" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      ########################################################################
      # 7) Upload ephemeral artifact (the .vip file)
      ########################################################################
      - name: Upload ephemeral artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.next_version.outputs.VERSION }}
          path: ${{ steps.find_vip.outputs.vip_path }}

      ########################################################################
      # 8) Create & push tag (skip if it's a PR)
      ########################################################################
      - name: Create & push tag
        if: ${{ github.event_name != 'pull_request' }}
        shell: pwsh
        run: |
          $VERSION = "${{ steps.next_version.outputs.VERSION }}"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a $VERSION -m "Auto-tag by CI for $VERSION"
          git push origin $VERSION

      ########################################################################
      # 9) Create GitHub Release
      ########################################################################
      - name: Create GitHub Release
        if: ${{ success() && github.event_name != 'pull_request' }}
        id: create_release
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const versionTag = '${{ steps.next_version.outputs.VERSION }}';
            const draftRelease = (process.env.DRAFT_RELEASE || 'true').toLowerCase() === 'true';
            const useAutoNotes = (process.env.USE_AUTO_NOTES || 'true').toLowerCase() === 'true';

            const createParams = {
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: versionTag,
              name: versionTag,
              draft: draftRelease
            };

            if (useAutoNotes) {
              createParams.generate_release_notes = true;
            } else {
              createParams.body = "Reference local release notes or embed within .vip.";
            }

            const response = await github.rest.repos.createRelease(createParams);
            core.setOutput("upload_url", response.data.upload_url);
            core.info(`Created release [draft=${draftRelease}] => ${versionTag}`);

      ########################################################################
      # 10) Attach ephemeral .vip to Release (if ATTACH_ARTIFACTS_TO_RELEASE==true)
      ########################################################################
      - name: Attach .vip to Release
        if: ${{ success() && env.ATTACH_ARTIFACTS_TO_RELEASE == 'true' && github.event_name != 'pull_request' }}
        shell: pwsh
        run: |
          $vipPath = '${{ steps.find_vip.outputs.vip_path }}'
          if (-not (Test-Path $vipPath)) {
            Write-Warning "VIP file not found at $vipPath"
            exit 0
          }

          $uploadUrl = '${{ steps.create_release.outputs.upload_url }}'
          if (-not $uploadUrl) {
            Write-Warning "No upload_url from create_release step."
            exit 0
          }

          $uploadUrlClean = $uploadUrl.Split('{')[0]
          $fileName = [System.IO.Path]::GetFileName($vipPath)
          $uri = "$uploadUrlClean?name=$fileName"

          Write-Host "Attaching $vipPath => $uri"

          $headers = @{
            "Authorization" = "Bearer $env:GITHUB_TOKEN"
            "Content-Type"  = "application/octet-stream"
          }

          Invoke-RestMethod `
            -Uri $uri `
            -Method POST `
            -Headers $headers `
            -InFile $vipPath

      ########################################################################
      # B) Re-enable GPG signing if it was disabled
      ########################################################################
      - name: Re-enable GPG signing (if disabled)
        if: ${{ always() && env.DISABLE_GPG_ON_FORKS == 'true' }}
        shell: pwsh
        run: |
          if ("${{ github.repository }}" -ne "ni/labview-icon-editor") {
            Write-Host "Restoring GPG signing..."
            $oldCommitGpgsign = '${{ steps.disable_signing.outputs.old_commit_gpgsign }}'
            $oldTagGpgsign    = '${{ steps.disable_signing.outputs.old_tag_gpgsign }}'

            if ($oldCommitGpgsign) {
              git config --global commit.gpgsign $oldCommitGpgsign
            } else {
              git config --global --unset commit.gpgsign || Write-Host "commit.gpgsign wasn't originally set."
            }

            if ($oldTagGpgsign) {
              git config --global tag.gpgsign $oldTagGpgsign
            } else {
              git config --global --unset tag.gpgsign || Write-Host "tag.gpgsign wasn't originally set."
            }
          } else {
            Write-Host "Official repo or DISABLE_GPG_ON_FORKS==false => no restore needed."
          }
